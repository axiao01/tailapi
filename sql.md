Reconciling Deployed Applications with Installed Software in MECM: A Comprehensive SQL ApproachExecutive Summary: Bridging Deployed Applications and Installed Software in MECMAccurately reconciling applications defined and deployed within Microsoft Endpoint Configuration Manager (MECM) with the actual software installed on client machines presents a significant challenge for IT administrators and database professionals. This task is often complicated by inherent discrepancies in application naming conventions between deployment records and inventory data, where names are frequently similar but not identical. Achieving precise reconciliation is paramount for effective software asset management, compliance reporting, and licensing audits.The solution presented in this report involves a multi-faceted SQL-based approach. It commences with a deep understanding of MECM's underlying database views, specifically distinguishing between deployment-related and inventory-related data. The report then pinpoints the precise location of application installation path information, an area often subject to misunderstanding. The core of the solution lies in employing advanced string manipulation and, where supported, fuzzy matching techniques to overcome naming inconsistencies. Finally, critical performance considerations and database best practices are emphasized, which are essential for running such complex queries efficiently in large-scale MECM environments. Readers will gain practical SQL query examples, a deeper understanding of MECM's data model, effective strategies for handling naming variations, and crucial advice on optimizing database performance to ensure reliable and efficient application reconciliation.Understanding MECM Application Data ViewsMECM manages software through a sophisticated database schema that differentiates between the intended state of application deployments and the actual inventory of installed software on client devices. This distinction is fundamental to understanding and reconciling application data.The Dual Nature of Application Data in MECMIn MECM, applications are logical entities that define software intended for deployment. While v_Applications conceptually represents these managed applications, their detailed deployment information is primarily found in related views such as v_DeploymentSummary, v_Program, and v_Advertisement.1 These views contain comprehensive details about an application's metadata, its various deployment types (e.g., MSI, Script Installer), associated requirements, and the specific collections to which they are targeted.2 This set of views collectively represents MECM's intent and blueprint for software distribution across the managed environment.Conversely, views such as v_GS_ADD_REMOVE_PROGRAMS and its 64-bit counterpart, v_GS_ADD_REMOVE_PROGRAMS_64 (or the more encompassing v_Add_Remove_Programs), capture software that is discovered and reported as installed on client machines.4 This inventory data is collected through MECM's hardware inventory process and typically mirrors entries found in the Windows Control Panel's "Add or Remove Programs" or "Programs and Features" list.7 This data represents the actual state of software on a client device at the time of the last inventory scan.The inherent difference in purpose between these two sets of views leads to common discrepancies. For instance, the DisplayName used for a deployed application in MECM might be a simplified, user-friendly name, whereas the DisplayName0 in v_GS_ADD_REMOVE_PROGRAMS often originates directly from the software installer's metadata. This can result in verbose names that include full version numbers, build details, or exhibit inconsistent casing and spacing.9 Furthermore, software can be installed manually on a client outside of MECM's deployment mechanisms, or MECM deployments might fail to detect an existing installation, leading to mismatches in reporting.2 This fundamental divergence in data origin necessitates a robust reconciliation method that explicitly accounts for these variations. The "similar but not identical" problem is not merely a data entry issue; it is a systemic consequence of MECM's architectural design, where application names in deployment records are often curated for administrative and user experience, while inventory data reflects the raw installer-provided names. This distinction dictates that simple string equality or basic pattern matching will be insufficient for comprehensive reconciliation.The ResourceID Link: Connecting Client-Specific DataA cornerstone of effectively querying MECM's database is the ResourceID column. This unique identifier serves as the primary key for linking client-specific inventory data, which is found in v_GS_ views (such as v_GS_ADD_REMOVE_PROGRAMS), to other system data views. Most notably, it connects to v_R_System, which contains core device discovery information like the device's NetBIOS name, operating system, and domain.4 When the objective is to join application deployment information (which is often collection-based or application-centric) with installed software, ResourceID acts as the crucial bridge. It enables the association of specific software installations with their respective client devices, providing a unified view of deployed and installed applications per machine.Table 1: Key MECM Application Data ViewsThe following table provides a foundational reference for understanding the most relevant MECM SQL views pertinent to application management and inventory. It offers a clear overview of their primary function and the common keys used for joining them, facilitating efficient navigation and query construction.View NamePrimary PurposeKey Fields (Examples)Common Join Keysv_AdvertisementLists information about deployed packages and programs, including deployment ID, name, package ID, and collection ID.AdvertisementID, AdvertisementName, PackageID, CollectionIDAdvertisementID, PackageID, CollectionIDv_DeploymentSummarySummarizes all active application deployments, including target collection, deployment name, and statistics.CollectionID, DeploymentName, PackageID, AdvertisementIDCollectionID, PackageID, AdvertisementIDv_ProgramLists programs for each package, including program name, package ID, and command line.ProgramName, PackageID, CommandLinePackageIDv_SMSPackageLists packages in the site hierarchy, including package ID, name, source files path.PkgID, Name, SourcePathPkgIDv_Add_Remove_ProgramsLists software installed on clients, registered in Windows Control Panel's Add/Remove Programs.MachineID, DisplayName, Version, PublisherResourceID, MachineIDv_GS_ADD_REMOVE_PROGRAMSClient-specific list of installed software from Add/Remove Programs (32-bit).ResourceID, DisplayName0, Version0, Publisher0ResourceIDv_GS_ADD_REMOVE_PROGRAMS_64Client-specific list of installed software from Add/Remove Programs (64-bit).ResourceID, DisplayName0, Version0, Publisher0ResourceIDv_GS_INSTALLED_SOFTWARE_CATEGORIZEDDetailed installed software with normalized names and installation locations.ResourceID, NormalizedName, InstalledLocation0, NormalizedPublisher, NormalizedVersionResourceIDv_GS_SoftwareProductLists products found on each Configuration Manager client.ResourceID, ProductName, ProductVersion, ProductPublisherResourceID, ProductIDv_GS_SoftwareFileLists files collected by software inventory on each client, including file path.ResourceID, FileName, FilePath, FileVersionResourceID, FileIDv_R_SystemCore system discovery data for all resources (computers).ResourceID, Name0, OperatingSystemNameandVersion0, ADSiteName0ResourceIDLocating Application Installation PathsIdentifying the exact installation location of applications is a common requirement for software asset management, troubleshooting, and auditing. However, the location of this information within MECM's database views requires clarification.Clarifying the InstallLocation Field: Where to Find It (and Where Not To)It is important to understand that a field explicitly named InstallLocation is not a standard or directly available column within the v_GS_ADD_REMOVE_PROGRAMS or v_GS_ADD_REMOVE_PROGRAMS_64 views.8 While these views provide fundamental information derived from the Windows Add/Remove Programs list, they typically do not include the complete installation path. Similarly, while v_Add_Remove_Programs is a comprehensive view for installed software, its listed schema does not explicitly contain an InstallLocation field.12Leveraging v_GS_INSTALLED_SOFTWARE_CATEGORIZED for InstalledLocation0The most reliable source for retrieving application installation paths in MECM's inventory is the v_GS_INSTALLED_SOFTWARE_CATEGORIZED view. This view contains the InstalledLocation0 field, which provides the file location path where the software is installed.8 This view often offers a more structured and normalized representation of installed software compared to the raw Add/Remove Programs data. Key fields available in this view for correlation include ResourceID, TimeStamp, NormalizedName (often aliased as DisplayName0), InstallDate0, NormalizedPublisher (as Publisher0), NormalizedVersion (as Version0), and the crucial InstalledLocation0.8The presence of InstalledLocation0 in v_GS_INSTALLED_SOFTWARE_CATEGORIZED but not in v_GS_ADD_REMOVE_PROGRAMS highlights a crucial aspect of MECM inventory: data granularity. v_GS_ADD_REMOVE_PROGRAMS is often considered a "legacy table" 15 providing basic Add/Remove Programs data. The InstalledLocation0 field being available in v_GS_INSTALLED_SOFTWARE_CATEGORIZED implies that this specific attribute is collected as part of a more detailed or categorized software inventory class. For this information to be available in the database, the underlying hardware inventory classes in MECM client settings must be explicitly configured to collect this specific data.5 Without proper client settings, the data will not be present in the database, regardless of the SQL query. This underscores that obtaining the installation path is not solely a SQL querying task but also depends on the MECM environment's configuration for hardware inventory collection.16Exploring Other Inventory Views for File Path DetailsFor more granular file-level path information, the v_GS_SoftwareFile view can be explored. This view lists individual files collected by software inventory on each client, including their FilePath.4 While useful for specific file investigations, it might be overly granular for a general "application installation location" query. It is important to remember that all v_GS_ views are client-specific and can be joined using the ResourceID column to link back to device details.4Table 2: Application Inventory Fields and Their Source ViewsThis table clarifies the correct field name for installation location and its primary source view, along with other essential application attributes.Common Field NameActual SQL Column NamePrimary Source View(s)Notes/ContextApplication Display NameDisplayName0, NormalizedNamev_GS_ADD_REMOVE_PROGRAMS, v_GS_ADD_REMOVE_PROGRAMS_64, v_GS_INSTALLED_SOFTWARE_CATEGORIZED, v_Add_Remove_ProgramsDisplayName0 from Add/Remove Programs; NormalizedName is a cleaned version.PublisherPublisher0, NormalizedPublisherv_GS_ADD_REMOVE_PROGRAMS, v_GS_ADD_REMOVE_PROGRAMS_64, v_GS_INSTALLED_SOFTWARE_CATEGORIZED, v_Add_Remove_ProgramsPublisher0 from Add/Remove Programs; NormalizedPublisher is a cleaned version.VersionVersion0, NormalizedVersionv_GS_ADD_REMOVE_PROGRAMS, v_GS_ADD_REMOVE_PROGRAMS_64, v_GS_INSTALLED_SOFTWARE_CATEGORIZED, v_Add_Remove_ProgramsVersion0 from Add/Remove Programs; NormalizedVersion is a cleaned version.Installation LocationInstalledLocation0v_GS_INSTALLED_SOFTWARE_CATEGORIZEDThe primary field for application installation paths. Requires specific hardware inventory class.Resource IDResourceID, MachineIDAll v_GS_ views, v_R_System, v_Add_Remove_ProgramsCrucial for joining client-specific data across views.Product IDProductIDv_GS_SoftwareProduct, v_SoftwareProductOften an MSI GUID; highly reliable for precise matching.File PathFilePathv_GS_SoftwareFileProvides paths for individual inventoried files.Strategies for Matching Similar Application NamesReconciling deployed application names with installed software names is complex due to inherent naming variations. Effective strategies involve a combination of string normalization and advanced matching techniques.Common Naming Discrepancies in MECMApplication names in MECM deployments (within the context of v_Applications and related views) and installed software inventory (from v_GS_ADD_REMOVE_PROGRAMS and similar views) frequently differ. These discrepancies can stem from various factors:
Version Numbers/Builds: Inventory data often includes full version numbers or build strings (e.g., "Adobe Acrobat Reader DC (2024.002.20736)"), while the deployed application name might be simplified ("Adobe Acrobat Reader DC").9
Inconsistent Casing/Spacing: Variations like "Microsoft Office" versus "microsoft office" or "Google Chrome" versus "GoogleChrome" are common.17
Publisher Variations: The publisher name might vary (e.g., "Microsoft Corporation" vs. "Microsoft").12
Suffixes/Prefixes: Examples include "7-Zip 23.01 (x64)" versus "7-Zip".
Manual Installations: Software installed outside of MECM's deployment process may adhere to entirely different naming conventions in the Add/Remove Programs list.12
Basic String Manipulation for NormalizationBefore attempting any advanced matching, normalizing the strings is a crucial first step. SQL Server provides several functions for this purpose:
TRIM(): This function removes leading and trailing whitespace from strings, which can otherwise cause false negatives in comparisons.17
UPPER() / LOWER(): These functions standardize casing, enabling case-insensitive comparisons.17 It is a best practice to convert both strings to the same case before comparison to ensure consistent results.
REPLACE(): This function can be used to substitute common variations (e.g., REPLACE(DisplayName, 'Corporation', '')) or remove specific unwanted characters.19
SUBSTR() / LEFT() / RIGHT(): These functions are useful for extracting specific parts of strings if naming patterns are consistent.17 For instance, if version numbers consistently appear at the end of a string, LEFT() can be used to truncate them.
REGEXP_REPLACE() (SQL Server 2022+ / Azure SQL): This powerful function allows for removing complex patterns, such as version numbers or other unwanted suffixes, using regular expressions.19 For example, REGEXP_REPLACE(DisplayName, '(\s(\d+\.)*\d+.*)$', '') can remove version numbers at the end of a string. It is important to note that this function is available in SQL Server 2022 and later, or Azure SQL Database. For environments running older versions of SQL Server, alternative string manipulation techniques or custom solutions would be necessary.
The practical application involves applying these functions to both the deployed application name (from the v_Applications context) and the installed software name (DisplayName0 from v_GS_ADD_REMOVE_PROGRAMS or v_GS_INSTALLED_SOFTWARE_CATEGORIZED) to create normalized strings for comparison. This process reduces the noise and variability in the data, making subsequent matching attempts more effective.Advanced Fuzzy Matching with SQL Server Functions (SQL Server 2025+ Preview)For situations where simple normalization is insufficient, such as minor typos or abbreviations, SQL Server 2025 (currently in preview) and Azure SQL Database offer powerful native fuzzy string matching functions.22
EDIT_DISTANCE_SIMILARITY: This function calculates a similarity score ranging from 0 to 100 based on the Levenshtein distance, which quantifies the number of insertions, deletions, substitutions, and transpositions needed to transform one string into another.22 This is highly effective for detecting typos or minor variations in application names.
JARO_WINKLER_SIMILARITY: This function calculates a similarity score ranging from 0 to 1 that gives preference to strings matching from the beginning.22 This is often more suitable for shorter names or when common prefixes are significant, as it weighs initial character similarities more heavily.24
A critical consideration is the compatibility of these fuzzy matching functions (EDIT_DISTANCE, JARO_WINKLER, and their _SIMILARITY counterparts). They are currently in preview and require SQL Server 2025 or Azure SQL Database.22 For environments running older versions of SQL Server, these functions will not be available, necessitating reliance on traditional string manipulation, LIKE comparisons, or potentially custom Common Language Runtime (CLR) functions.Furthermore, these fuzzy matching functions are case-sensitive by default.22 Therefore, it is essential to apply LOWER() or UPPER() to both strings before using these functions to ensure case-insensitive comparisons, which is crucial for accurate application name matching in most real-world scenarios.When utilizing fuzzy matching, a critical trade-off arises between precision and recall. A higher similarity threshold (e.g., JARO_WINKLER_SIMILARITY >= 0.95) will yield high precision, meaning the matches identified are very likely correct, but may result in lower recall, missing some legitimate matches due to slightly larger discrepancies. Conversely, a lower threshold (e.g., >= 0.75) will increase recall, capturing more potential matches, but at the risk of higher false positives, where dissimilar applications might be incorrectly matched. The optimal threshold is not universal and depends on the specific data quality in the MECM environment, the acceptable error rate for reporting, and the business context of the reconciliation.Combining Multiple Attributes for Robust MatchingRelying solely on DisplayName (even after normalization or fuzzy matching) can lead to false positives, especially for generic application names. A more robust strategy involves combining multiple attributes for matching:
Publisher: Matching on Publisher (e.g., Publisher0 in v_GS_ADD_REMOVE_PROGRAMS) is often a strong initial filter, significantly narrowing down potential matches.12 It is advisable to normalize publisher names as well (e.g., REPLACE('Microsoft Corporation', ' Corporation', '')).
Version: While full version strings can vary, matching on major version numbers or a fuzzy version match can further improve accuracy.12
ProductID / MSI GUID: For MSI-based applications, the ProductID (which is typically a unique GUID) offers the most precise and unique identifier for matching. This is often how MECM's internal detection methods operate to determine if an application is installed.12 If this attribute is consistently available in both deployment and inventory data, it should be prioritized for matching, as it provides a highly reliable and less "fuzzy" match key.
The most robust and practical matching strategy is a hybrid, multi-layered approach. This involves:
Initial Normalization: Apply standard string functions (TRIM, UPPER, REGEXP_REPLACE) to both DisplayName and Publisher fields to clean and standardize the data, reducing obvious discrepancies.
Prioritized Exact Matching: Attempt exact matches on unique identifiers like ProductID (if available in both datasets) and the normalized Publisher and Version fields. These provide the highest reliability.
Fuzzy Matching as a Fallback/Supplement: Only if exact matches are insufficient or unavailable, apply fuzzy matching (e.g., JARO_WINKLER_SIMILARITY) on the normalized DisplayName fields. This sequential approach minimizes the computational overhead of fuzzy matching by applying it to a pre-filtered, smaller dataset and ensures compatibility across different SQL Server versions (by providing an alternative if fuzzy functions are not available). This iterative refinement of matching logic is crucial; starting with basic comparisons reveals limitations, leading to the incorporation of normalization, then fuzzy matching, and finally, integrating multiple attributes to enhance accuracy and reduce false positives. This systematic approach mirrors real-world data quality challenges.
Table 3: SQL Server String Manipulation and Fuzzy Matching FunctionsThis table details the specific SQL functions available for cleaning, normalizing, and performing approximate matching on application names.Function NameCategoryDescriptionExample Use Case (for App Names)Compatibility/NotesTRIM()String NormalizationRemoves leading and trailing whitespace.TRIM(' App Name ') -> 'App Name'Standard SQLUPPER() / LOWER()String NormalizationConverts string to all uppercase or all lowercase.UPPER('Adobe Reader') -> 'ADOBE READER'Standard SQL; use for case-insensitive comparisons.REPLACE()String NormalizationReplaces all occurrences of a specified substring with another.REPLACE('Microsoft Corp.', 'Corp.', '') -> 'Microsoft'Standard SQLSUBSTR() / LEFT() / RIGHT()String NormalizationExtracts a substring from a string.LEFT('App v1.2', 3) -> 'App'Standard SQL; useful for consistent patterns.REGEXP_REPLACE()String NormalizationReplaces substrings matching a regular expression pattern.REGEXP_REPLACE('App 1.2.3', '(\s(\d+\.)*\d+.*)$', '') -> 'App'SQL Server 2022+ / Azure SQL DB; powerful for complex patterns like version numbers.EDIT_DISTANCE_SIMILARITYFuzzy MatchingCalculates similarity (0-100) based on character edits needed to transform one string to another.EDIT_DISTANCE_SIMILARITY('Google Chrome', 'Google Chrone') -> 89SQL Server 2025+ Preview / Azure SQL DB; case-sensitive by default, use LOWER() for case-insensitivity.JARO_WINKLER_SIMILARITYFuzzy MatchingCalculates similarity (0-1) giving preference to initial matching characters.JARO_WINKLER_SIMILARITY('MS Office', 'Microsoft Office') -> 0.9SQL Server 2025+ Preview / Azure SQL DB; case-sensitive by default, use LOWER() for case-insensitivity.Constructing Comprehensive SQL QueriesTo effectively reconcile application records and retrieve installation locations, specific SQL queries are required. The following examples illustrate how to build these queries, incorporating the strategies discussed previously.Prerequisites for QueryingTo execute these queries, access to SQL Server Management Studio (SSMS) or a similar SQL client is necessary.6 It is essential to ensure that the querying account has appropriate read-only access to the MECM database. The SCCM database is typically named CM_XXX, where XXX represents the site code.6 A best practice for reporting is to use a dedicated SQL local user with read-only permissions.15 Familiarity with basic SQL clauses (SELECT, FROM, JOIN, WHERE) is assumed for effective utilization of these examples.6Query 1: Linking Deployed Applications to Installed Software (Initial Match)This query serves as a foundational starting point, demonstrating how to join deployment records with installed software inventory. It uses a simple LIKE comparison on DisplayName, which will likely miss many matches due to naming variations but illustrates the basic join structure.The query joins v_DeploymentSummary (for deployment details) with v_Advertisement and v_Program to retrieve the deployed application's display name. This information is then joined to v_Add_Remove_Programs (for installed software) using ResourceID and a basic LIKE clause on the display names. The v_R_System view is included to provide the device's name.SQLSELECT DISTINCT
    ds.CollectionID,
    ds.DeploymentName AS DeployedAppName,
    ad.DisplayName AS DeployedAppDisplayName, -- Actual display name from advertisement/application
    arp.DisplayName0 AS InstalledAppName,
    arp.Version0 AS InstalledVersion,
    arp.Publisher0 AS InstalledPublisher,
    arp.ResourceID AS DeviceResourceID,
    vrs.Name0 AS DeviceName
FROM
    CM_XXX.dbo.v_DeploymentSummary AS ds
JOIN
    CM_XXX.dbo.v_Advertisement AS ad ON ds.AdvertisementID = ad.AdvertisementID
JOIN
    CM_XXX.dbo.v_Program AS pr ON ds.PackageID = pr.PackageID
JOIN
    CM_XXX.dbo.v_Add_Remove_Programs AS arp ON ds.ResourceID = arp.ResourceID
JOIN
    CM_XXX.dbo.v_R_System AS vrs ON arp.ResourceID = vrs.ResourceID
WHERE
    -- Basic LIKE comparison for initial matching
    ad.DisplayName LIKE '%' + arp.DisplayName0 + '%'
    OR arp.DisplayName0 LIKE '%' + ad.DisplayName + '%'
ORDER BY
    DeviceName, DeployedAppName;
Query 2: Incorporating String Normalization and Fuzzy Matching for Improved AccuracyThis query demonstrates how to apply the normalization and fuzzy matching strategies discussed earlier. It uses UPPER(), TRIM(), and REGEXP_REPLACE() for cleaning, and then JARO_WINKLER_SIMILARITY for fuzzy comparison.The query first normalizes the DisplayName and Publisher fields from both the deployed application and installed software. Normalization includes converting to uppercase, trimming whitespace, and utilizing REGEXP_REPLACE to remove common version number patterns.17 The WHERE clause then combines an exact match on normalized publisher with a fuzzy similarity score (e.g., >= 0.8) on the normalized display names. This approach significantly improves matching accuracy by addressing common naming discrepancies.12SQLSELECT DISTINCT
    ds.CollectionID,
    ds.DeploymentName AS DeployedAppName,
    ad.DisplayName AS DeployedAppDisplayName,
    arp.DisplayName0 AS InstalledAppName,
    arp.Version0 AS InstalledVersion,
    arp.Publisher0 AS InstalledPublisher,
    vrs.Name0 AS DeviceName,
    arp.ResourceID AS DeviceResourceID,
    -- Normalized names for comparison
    UPPER(TRIM(REGEXP_REPLACE(ad.DisplayName, '(\s(\d+\.)*\d+.*)$', ''))) AS NormalizedDeployedName,
    UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', ''))) AS NormalizedInstalledName,
    -- Fuzzy similarity score (requires SQL Server 2025+ or Azure SQL DB)
    JARO_WINKLER_SIMILARITY(
        UPPER(TRIM(REGEXP_REPLACE(ad.DisplayName, '(\s(\d+\.)*\d+.*)$', ''))),
        UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', '')))
    ) AS JaroWinklerScore
FROM
    CM_XXX.dbo.v_DeploymentSummary AS ds
JOIN
    CM_XXX.dbo.v_Advertisement AS ad ON ds.AdvertisementID = ad.AdvertisementID
JOIN
    CM_XXX.dbo.v_Program AS pr ON ds.PackageID = pr.PackageID
JOIN
    CM_XXX.dbo.v_Add_Remove_Programs AS arp ON ds.ResourceID = arp.ResourceID
JOIN
    CM_XXX.dbo.v_R_System AS vrs ON arp.ResourceID = vrs.ResourceID
WHERE
    -- Combine normalized publisher match with fuzzy display name match
    UPPER(TRIM(ad.Publisher)) = UPPER(TRIM(arp.Publisher0)) -- Exact match on normalized publisher
    AND JARO_WINKLER_SIMILARITY(
        UPPER(TRIM(REGEXP_REPLACE(ad.DisplayName, '(\s(\d+\.)*\d+.*)$', ''))),
        UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', '')))
    ) >= 0.8 -- Adjust threshold as needed (0.8 to 0.95 is common)
ORDER BY
    DeviceName, DeployedAppName;
For environments running SQL Server versions older than 2025 (or not on Azure SQL Database), the fuzzy matching functions (JARO_WINKLER_SIMILARITY, EDIT_DISTANCE_SIMILARITY) will not be available.22 In such cases, the query must rely solely on string normalization and LIKE comparisons with wildcards, potentially combined with CHARINDEX or PATINDEX for more complex pattern matching. A common approach for older SQL Server versions would be to use:WHERE UPPER(TRIM(ad.Publisher)) = UPPER(TRIM(arp.Publisher0)) AND UPPER(TRIM(ad.DisplayName)) LIKE '%' + UPPER(TRIM(arp.DisplayName0)) + '%' OR UPPER(TRIM(arp.DisplayName0)) LIKE '%' + UPPER(TRIM(ad.DisplayName)) + '%'This fallback ensures compatibility while still providing a degree of flexibility in matching.Query 3: Retrieving Installation Locations for Matched ApplicationsThis query extends the previous matching logic to include the application installation path, leveraging the v_GS_INSTALLED_SOFTWARE_CATEGORIZED view.The query takes the results from the robust matching logic (similar to Query 2) and further joins with v_GS_INSTALLED_SOFTWARE_CATEGORIZED. This join is performed using ResourceID to link to the correct client and a match on the DisplayName0 (or NormalizedName) to retrieve the InstalledLocation0 field.8 It is critical to ensure that the hardware inventory is configured to collect this specific information within MECM client settings for InstalledLocation0 to be populated.SQLSELECT DISTINCT
    ds.CollectionID,
    ds.DeploymentName AS DeployedAppName,
    ad.DisplayName AS DeployedAppDisplayName,
    arp.DisplayName0 AS InstalledAppName,
    isc.InstalledLocation0, -- The actual installation path
    arp.Version0 AS InstalledVersion,
    arp.Publisher0 AS InstalledPublisher,
    vrs.Name0 AS DeviceName,
    arp.ResourceID AS DeviceResourceID
FROM
    CM_XXX.dbo.v_DeploymentSummary AS ds
JOIN
    CM_XXX.dbo.v_Advertisement AS ad ON ds.AdvertisementID = ad.AdvertisementID
JOIN
    CM_XXX.dbo.v_Program AS pr ON ds.PackageID = pr.PackageID
JOIN
    CM_XXX.dbo.v_Add_Remove_Programs AS arp ON ds.ResourceID = arp.ResourceID
JOIN
    CM_XXX.dbo.v_R_System AS vrs ON arp.ResourceID = vrs.ResourceID
JOIN
    CM_XXX.dbo.v_GS_INSTALLED_SOFTWARE_CATEGORIZED AS isc
    ON arp.ResourceID = isc.ResourceID
    AND UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', ''))) = UPPER(TRIM(isc.NormalizedName)) -- Match on normalized names
WHERE
    -- Apply your best matching logic here (normalized names, fuzzy scores, publisher, version)
    UPPER(TRIM(ad.Publisher)) = UPPER(TRIM(arp.Publisher0))
    AND JARO_WINKLER_SIMILARITY(
        UPPER(TRIM(REGEXP_REPLACE(ad.DisplayName, '(\s(\d+\.)*\d+.*)$', ''))),
        UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', '')))
    ) >= 0.8
ORDER BY
    DeviceName, DeployedAppName;
Advanced Query: Identifying Unmanaged Installations (Software Not Deployed by SCCM)This related query is highly valuable for identifying "rogue" software or applications installed manually outside of MECM's management. It provides visibility into software that might not be compliant with organizational policies or licensing agreements.By performing a LEFT JOIN from v_Add_Remove_Programs (representing all installed software on clients) to v_DeploymentSummary (representing SCCM-deployed software), and then filtering for cases where the deployment record is NULL, the query effectively identifies software installed on machines that has no corresponding MECM deployment record.12 The use of normalized names in the JOIN condition enhances the accuracy of this identification.SQLSELECT DISTINCT
    arp.MachineID,
    vrs.Name0 AS DeviceName,
    arp.DisplayName0 AS InstalledAppName,
    arp.Version0 AS InstalledVersion,
    arp.Publisher0 AS InstalledPublisher
FROM
    CM_XXX.dbo.v_Add_Remove_Programs AS arp
JOIN
    CM_XXX.dbo.v_R_System AS vrs ON arp.MachineID = vrs.ResourceID
LEFT JOIN
    CM_XXX.dbo.v_DeploymentSummary AS ds
    ON arp.ResourceID = ds.ResourceID
    AND UPPER(TRIM(REGEXP_REPLACE(arp.DisplayName0, '(\s(\d+\.)*\d+.*)$', ''))) = UPPER(TRIM(REGEXP_REPLACE(ds.DeploymentName, '(\s(\d+\.)*\d+.*)$', ''))) -- Match on normalized names for better accuracy
WHERE
    ds.DeploymentName IS NULL -- Where there is no matching SCCM deployment record
ORDER BY
    DeviceName, InstalledAppName;
Performance Considerations for SQL Queries in MECMExecuting complex SQL queries, especially those involving string manipulation and fuzzy matching, on large MECM databases can be resource-intensive. Optimizing query performance is crucial for maintaining database responsiveness and ensuring timely reporting.Optimizing Query Performance
Indexing: Ensure appropriate indexes are in place on columns frequently used in JOIN clauses (e.g., ResourceID, DisplayName0, Publisher0) and WHERE clauses. Properly indexed tables can significantly reduce query execution time.
Selective Data Retrieval: Avoid using SELECT *. Instead, specify only the columns required in the SELECT statement to minimize data transfer and processing overhead.6
Batch Processing/Scheduling: For very large datasets, consider breaking down complex reconciliation tasks into smaller, manageable batches. Schedule these queries to run during off-peak hours to minimize impact on the MECM site database server and other critical operations.29
Database Maintenance: Regular database maintenance, including index defragmentation and statistics updates, is vital for optimal SQL Server performance in MECM environments.30 Fragmented indexes can significantly slow down query execution.
Hardware Sizing: MECM performance is heavily dependent on SQL Server hardware. For large environments, ensure the SQL Server instance is adequately resourced with sufficient CPU, memory, and fast storage, ideally on a remote site system for reporting services.29 Aggressive inventory collection cycles or a high number of collections and applications can dramatically increase the load on the SQL Server, necessitating oversized hardware.31
Query Optimization Tools: Utilize SQL Server tools such as Query Analyzer and Profiler to identify performance bottlenecks within queries. These tools can help in understanding query execution plans and pinpointing areas for optimization.29
Impact of String Functions and Fuzzy MatchingString manipulation functions (UPPER, TRIM, REPLACE, REGEXP_REPLACE) and especially fuzzy matching functions (EDIT_DISTANCE_SIMILARITY, JARO_WINKLER_SIMILARITY) can be computationally expensive, particularly when applied to large text fields or across millions of rows.22
CPU Utilization: These functions require significant CPU resources to process string comparisons and transformations.
Lack of Index Utilization: Most string functions prevent the effective use of indexes on the columns they operate on, forcing full table scans and increasing query execution time.
Compatibility and Performance: The newer fuzzy matching functions, while powerful, are still in preview for SQL Server 2025 and require Azure SQL Database.22 Their performance characteristics on very large, on-premises MECM databases should be thoroughly tested in a non-production environment before deployment.24
To mitigate performance impact, the hybrid matching strategy is particularly beneficial. By performing initial normalization and prioritizing exact matches on unique identifiers (like ProductID) and normalized Publisher and Version fields, the number of records that require computationally intensive fuzzy matching can be significantly reduced. This approach ensures that fuzzy matching is applied only when necessary, minimizing its performance overhead.Conclusions and RecommendationsReconciling deployed applications with installed software in MECM, especially when application names are similar but not identical, is a complex but achievable task through strategic SQL querying. The process requires a deep understanding of MECM's database schema, careful application of string manipulation and fuzzy matching techniques, and diligent attention to performance optimization.Key Conclusions:
Data Origin Drives Discrepancies: The fundamental difference in how MECM stores deployed application names (curated for management and user experience) versus how it collects installed software names (raw from installer metadata) is the root cause of naming discrepancies. This necessitates advanced matching techniques beyond simple string equality.
Installation Path Specificity: The InstallLocation field is not directly available in v_GS_ADD_REMOVE_PROGRAMS. The correct source for this information is InstalledLocation0 within the v_GS_INSTALLED_SOFTWARE_CATEGORIZED view. The availability of this data hinges on the proper configuration of hardware inventory classes in MECM client settings.
Hybrid Matching is Optimal: A multi-layered approach to matching is most effective. This involves:

Normalization: Standardizing names using TRIM(), UPPER(), and REGEXP_REPLACE() to eliminate trivial variations.
Prioritized Exact Matching: Leveraging unique identifiers like ProductID (for MSI-based applications) and exact matches on normalized Publisher and Version fields for high-confidence matches.
Fuzzy Matching (Conditional): Employing JARO_WINKLER_SIMILARITY or EDIT_DISTANCE_SIMILARITY on normalized names as a fallback for subtle variations, acknowledging their compatibility requirements (SQL Server 2025+ Preview / Azure SQL Database) and performance implications.


ResourceID is the Unifying Key: For all client-specific data, ResourceID serves as the crucial join column, enabling the linkage of installed software to specific devices and their deployment statuses.
Performance is Paramount: Complex string operations and fuzzy matching can significantly impact SQL Server performance. Proactive measures such as indexing, selective data retrieval, scheduled execution, and robust hardware sizing are critical for maintaining database health and query efficiency.
Actionable Recommendations:
Verify MECM Inventory Configuration: Before attempting to query for installation locations, verify that the MECM hardware inventory client settings are configured to collect the InstalledLocation0 attribute, typically found within the v_GS_INSTALLED_SOFTWARE_CATEGORIZED class. If not, enable this collection to ensure the data is populated in the database.
Adopt a Hybrid SQL Matching Strategy: Implement the recommended hybrid SQL query approach:

Begin by applying UPPER() and TRIM() to all relevant DisplayName and Publisher fields.
If using SQL Server 2022+ or Azure SQL Database, integrate REGEXP_REPLACE() to remove common version number patterns or other undesirable suffixes from application names.
Prioritize matching on ProductID where available, as it offers the most precise identifier.
Supplement with exact matches on normalized Publisher and Version.
For remaining discrepancies, and if on a compatible SQL Server version, use JARO_WINKLER_SIMILARITY with an appropriate threshold (e.g., 0.8 to 0.95) on the normalized DisplayName fields. Adjust the threshold based on the acceptable balance between precision and recall for reporting needs.


Optimize SQL Server Performance:

Indexing: Regularly review and create appropriate indexes on columns involved in JOIN and WHERE clauses, particularly ResourceID, DisplayName0, Publisher0, and NormalizedName.
Selective Queries: Always specify only the necessary columns in SELECT statements instead of using SELECT *.
Scheduled Execution: For large-scale reconciliation reports, schedule queries to run during off-peak hours to minimize impact on production systems.
Hardware Review: Ensure the SQL Server hosting the MECM database is adequately provisioned, especially if extensive string manipulation or fuzzy matching is anticipated.


Leverage Unmanaged Software Reporting: Regularly utilize the provided SQL query to identify "unmanaged" software installations. This is crucial for maintaining software compliance, identifying unauthorized installations, and informing licensing audits.
Test in a Non-Production Environment: Before deploying complex SQL queries, especially those utilizing new fuzzy matching functions, thoroughly test their performance and accuracy in a non-production MECM environment that mirrors the scale and data characteristics of the production system.
